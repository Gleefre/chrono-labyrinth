(in-package #:chrono-labyrinth)

(s:defsketch game-window ((s:title "Chrono Labyrinth")
                          (game (make-game)))
  (let ((*game* game)
        (*game-window* s::*sketch*))
    (draw-game s:width s:height)))

(defmethod kit.sdl2:keyboard-event ((game game-window) state ts rep? keysym)
  (when (and (eq state :keydown)
             (not rep?))
    (if (not (lose? (car (history *game*))))
        (case (sdl2:scancode keysym)
          ((:scancode-w :scancode-up)
           (setf (player-action (object-by-name :player)) :up)
           (push (next-world *world*) (history *game*)))
          ((:scancode-s :scancode-down)
           (setf (player-action (object-by-name :player)) :down)
           (push (next-world *world*) (history *game*)))
          ((:scancode-a :scancode-left)
           (setf (player-action (object-by-name :player)) :left)
           (push (next-world *world*) (history *game*)))
          ((:scancode-d :scancode-right)
           (setf (player-action (object-by-name :player)) :right)
           (push (next-world *world*) (history *game*)))
          ((:scancode-z)
           (unless (null (cdr (history *game*)))
             (pop (history *game*)))))
        (case (sdl2:scancode keysym)
          ((:scancode-r)
           (setf (history *game*) (last (history *game*))))))))

(s:define-start-function (start) game-window
                         (:resizable t :width 800 :height 500))

(defmethod kit.sdl2:mousebutton-event :around ((window game-window) state ts button x y)
  (let ((*game* (game-window-game window))
        (*game-window* window))
    (let ((*world* (car (history *game*))))
      (call-next-method))))

(defmethod kit.sdl2:keyboard-event :around ((window game-window) state ts rep? keysym)
  (let ((*game* (game-window-game window))
        (*game-window* window))
    (let ((*world* (car (history *game*))))
      (call-next-method))))
